![Steel banner](./steel-banner.png)

# Steel - Hardened off-chain Execution for EVM dapps

> ***WARNING***: This library is still in its experimental phase and under active development. Production use is not recommended until the software has matured sufficiently.

In the realm of Ethereum and smart contracts, obtaining data directly from the blockchain without altering its state—known as "view calls" — are a fundamental operation.
Traditionally, these operations, especially when it comes to proving and verifying off-chain computations, involve a degree of complexity: either via proof of storage mechanisms requiring detailed knowledge of slot indexes, or via query-specific circuit development.

In contrast, this library abstracts away these complexities, allowing developers to query Ethereum's state by just defining the Solidity method they wish to call.
To demonstrate a simple instance of using the view call library, let's consider possibly the most common view call: querying the balance of an ERC-20 token for a specific address.
You can find the full example [here](../examples/erc20/README.md).

## Guest Code

Here is a snippet of the [relevant code](../examples/erc20/methods/guest/src/main.rs) of the guest:

```rust
/// Specify the function to call using the [`sol!`] macro.
/// This parses the Solidity syntax to generate a struct that implements the [SolCall] trait.
/// The struct instantiated with the arguments can then be passed to the [ViewCall] to execute the
/// call. For example:
/// `IERC20::balanceOfCall { account: address!("9737100D2F42a196DE56ED0d1f6fF598a250E7E4") }`
sol! {
    /// ERC-20 balance function signature.
    interface IERC20 {
        function balanceOf(address account) external view returns (uint);
    }
}

/// Function to call, implements [SolCall] trait.
const CALL: IERC20::balanceOfCall =
    IERC20::balanceOfCall { account: address!("9737100D2F42a196DE56ED0d1f6fF598a250E7E4") };

/// Address of the deployed contract to call the function on. Here: USDT contract on Sepolia
const CONTRACT: Address = address!("aA8E23Fb1079EA71e0a56F48a2aA51851D8433D0");
/// Address of the caller of the function. If not provided, the caller will be the [CONTRACT].
const CALLER: Address = address!("f08A50178dfcDe18524640EA6618a1f965821715");

fn main() {
    // Read the input from the guest environment.
    let input: EthViewCallInput = env::read();

    // Converts the input into a `ViewCallEnv` for execution. The `with_chain_spec` method is used
    // to specify the chain configuration. It checks that the state matches the state root in the
    // header provided in the input.
    let view_call_env = input.into_env().with_chain_spec(&ETH_SEPOLIA_CHAIN_SPEC);
    // Commit the block hash and number used when deriving `view_call_env` to the journal.
    env::commit_slice(&view_call_env.block_commitment().abi_encode());

    // Execute the view call; it returns the result in the type generated by the `sol!` macro.
    let returns = view_call_env.execute(ViewCall::new(CALL, CONTRACT).with_caller(CALLER));
    println!("View call result: {}", returns._0);
}
```

## Host Code

Here is a snippet to the [relevant code](../examples/erc20/host/src/main.rs) on the host, it requires the same arguments as the guest:

```rust
// Create a view call environment from an RPC endpoint and a block number. If no block number is
// provided, the latest block is used. The `with_chain_spec` method is used to specify the
// chain configuration.
let mut env = EthViewCallEnv::from_rpc(&RPC_URL, None)?
    .with_chain_spec(&ETH_SEPOLIA_CHAIN_SPEC);

// Preflight the view call to construct the input that is required to execute the function in
// the guest. It also returns the result of the call.
let returns = env.preflight(ViewCall::new(CALL, CONTRACT).with_caller(CALLER))?;
let input = env.into_zkvm_input()?;
```

## Ethereum Integration

This library can be used in conjunction with the [Bonsai Foundry Template]. The Ethereum Contract that validates the Groth16 proof must also validate the `ViewCallEnv` commitment. This commitment is the ABI-encoded bytes of the following type:

```solidity
struct BlockCommitment {
    bytes32 blockHash;
    uint blockNumber;
}
```

Here's an example of how to implement the validation:

```solidity
function validate(bytes calldata journal, bytes calldata seal) public {
    BlockCommitment memory commitment = abi.decode(journal, (BlockCommitment));
    require(blockhash(commitment.blockNumber) == commitment.blockHash);
    require(verifier.verify(seal, imageId, sha256(journal)));
}
```

We also provide an example, [erc20-counter], showcasing such integration.

### Getting the verified block hash

If the `blockhash` opcode is used for validation, the commitment must not be older than 256 blocks.
Given a block time of 12 seconds, this allows just over 50 minutes to create the proof and ensure that the validating transaction is included in a block.
In many cases, this will work just fine: even very large computations such as proving an entire Ethereum block can be done in well under 50 minutes with sufficient resources.

When a verified block hash older than 256 blocks is needed on-chain, a number of strategies can be used:

* When the block hash that will be needed is known ahead of time (e.g. when initiating a proposal for governance), that block hash can be saved to contract state.
* Another approach is to use RISC Zero to prove the hash chain from the block that was queried up until a block in the most recent 256.

[erc20-counter]: ./examples/erc20-counter/README.md
[Bonsai Foundry Template]: https://github.com/risc0/bonsai-foundry-template
