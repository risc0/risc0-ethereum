// Copyright 2025 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::path::PathBuf;

use clap::Parser;
use risc0_aggregation::{GuestState, SetInclusionReceipt, SetInclusionReceiptVerifierParameters};
use risc0_ethereum_test_utils_guests::{ECHO_ELF, ECHO_ID};
use risc0_zkvm::{default_prover, sha::Digestible, Digest, ExecutorEnv, ProverOpts, ReceiptClaim};

#[derive(Parser, Clone, Debug)]
struct MainArgs {
    #[clap(long)]
    /// Path to the set builder ELF file
    path: PathBuf,

    #[clap(long)]
    /// Optional path to write the generated Solidity library
    ///
    /// (defaults to contracts/test/TestSetInclusionReceipt.sol)
    out: Option<PathBuf>,
}

/// Utility to generate test receipts for the set builder.
fn main() {
    let args = MainArgs::parse();

    println!("Set Builder ELF path: {}", args.path.display());
    let set_builder_elf = std::fs::read(&args.path).expect("Failed to read ELF file");
    let set_builder_image_id =
        risc0_zkvm::compute_image_id(&set_builder_elf).expect("Failed to compute image ID");
    println!("Set Builder image ID: {set_builder_image_id}");
    let set_inclusion_digest = SetInclusionReceiptVerifierParameters {
        image_id: set_builder_image_id,
    }
    .digest();
    println!("SetInclusionReceiptVerifierParameters {set_inclusion_digest}");

    let env = ExecutorEnv::builder()
        .write(b"echo_test")
        .expect("Failed to build input")
        .build()
        .expect("Failed to build executor environment");
    let receipt = default_prover()
        .prove(env, ECHO_ELF)
        .expect("Failed to prove echo guest")
        .receipt;
    let journal = receipt.journal.bytes.clone();
    let claim = ReceiptClaim::ok(ECHO_ID, journal.clone());

    let claims = vec![claim.clone()];
    let input = GuestState::initial(set_builder_image_id)
        .into_input(claims, true)
        .expect("Failed to build set builder input");
    let encoded_input: Vec<u8> = bytemuck::pod_collect_to_vec(
        &risc0_zkvm::serde::to_vec(&input).expect("Failed to serialize input"),
    );
    let env = ExecutorEnv::builder()
        .write_slice(&encoded_input)
        .add_assumption(receipt)
        .build()
        .expect("Failed to build executor environment");
    let root_receipt = default_prover()
        .prove_with_opts(env, &set_builder_elf, &ProverOpts::groth16())
        .expect("Failed to prove set builder guest")
        .receipt;

    let set_verifier_receipt =
        SetInclusionReceipt::from_path_with_verifier_params(claim, vec![], set_inclusion_digest)
            .with_root(root_receipt);

    let seal = set_verifier_receipt
        .abi_encode_seal()
        .expect("Failed to encode seal");

    // Write the seal and other relevant information to fill the test receipt
    let content = format!(
        r#"// Copyright 2025 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

// This file is automatically generated by:
// cargo run --bin set-inclusion-test-receipt -- --path [set-builder-elf-path]

pragma solidity ^0.8.13;

library TestSetInclusionReceipt {{
bytes public constant SEAL = hex"{seal_hex}";
bytes public constant JOURNAL = hex"{journal_hex}";
bytes32 public constant IMAGE_ID = hex"{image_id}";
}}
"#,
        seal_hex = hex::encode(seal),
        journal_hex = hex::encode(journal),
        image_id = Digest::from(ECHO_ID),
    );
    let out_path = args
        .out
        .unwrap_or_else(|| PathBuf::from("contracts/test/TestSetInclusionReceipt.sol"));
    std::fs::write(&out_path, content).expect("Failed to write Solidity output");
    println!("Wrote TestSetInclusionReceipt to {}", out_path.display());
    forge_fmt(&out_path).expect("Failed to format Solidity output");
}

fn forge_fmt(path: &PathBuf) -> Result<(), anyhow::Error> {
    let status = std::process::Command::new("forge")
        .arg("fmt")
        .arg(path)
        .status()?;
    if !status.success() {
        anyhow::bail!("`forge fmt` failed");
    }
    Ok(())
}
